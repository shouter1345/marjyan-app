#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define SIZE 4

// 4x4行列の型定義
typedef double Matrix4x4[SIZE][SIZE];

// 関数プロトタイプ
void print_matrix(Matrix4x4 matrix, const char* name);
void add_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result);
void subtract_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result);
void multiply_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result);
void scalar_multiply(Matrix4x4 matrix, double scalar, Matrix4x4 result);
void transpose_matrix(Matrix4x4 matrix, Matrix4x4 result);
double determinant_4x4(Matrix4x4 matrix);
double determinant_3x3(double matrix[3][3]);
int inverse_matrix(Matrix4x4 matrix, Matrix4x4 result);
double trace_matrix(Matrix4x4 matrix);
void copy_matrix(Matrix4x4 src, Matrix4x4 dest);
void identity_matrix(Matrix4x4 matrix);

// 行列を表示する関数
void print_matrix(Matrix4x4 matrix, const char* name) {
    printf("%s:\n", name);
    for (int i = 0; i < SIZE; i++) {
        printf("[ ");
        for (int j = 0; j < SIZE; j++) {
            printf("%8.2f ", matrix[i][j]);
        }
        printf("]\n");
    }
    printf("\n");
}

// 行列の加算
void add_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = a[i][j] + b[i][j];
        }
    }
}

// 行列の減算
void subtract_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = a[i][j] - b[i][j];
        }
    }
}

// 行列の乗算
void multiply_matrices(Matrix4x4 a, Matrix4x4 b, Matrix4x4 result) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = 0;
            for (int k = 0; k < SIZE; k++) {
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }
}

// スカラー倍
void scalar_multiply(Matrix4x4 matrix, double scalar, Matrix4x4 result) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = matrix[i][j] * scalar;
        }
    }
}

// 転置行列
void transpose_matrix(Matrix4x4 matrix, Matrix4x4 result) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[j][i] = matrix[i][j];
        }
    }
}

// 3x3行列の行列式
double determinant_3x3(double matrix[3][3]) {
    return matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
         - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
         + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
}

// 4x4行列の行列式
double determinant_4x4(Matrix4x4 matrix) {
    double det = 0;
    double submatrix[3][3];
    int sign = 1;
    
    for (int col = 0; col < SIZE; col++) {
        // 余因子行列を作成
        int sub_i = 0;
        for (int i = 1; i < SIZE; i++) {
            int sub_j = 0;
            for (int j = 0; j < SIZE; j++) {
                if (j != col) {
                    submatrix[sub_i][sub_j] = matrix[i][j];
                    sub_j++;
                }
            }
            sub_i++;
        }
        
        det += sign * matrix[0][col] * determinant_3x3(submatrix);
        sign = -sign;
    }
    
    return det;
}

// 逆行列の計算
int inverse_matrix(Matrix4x4 matrix, Matrix4x4 result) {
    double det = determinant_4x4(matrix);
    
    if (fabs(det) < 1e-10) {
        printf("エラー: 行列は特異行列です（逆行列が存在しません）\n");
        return 0;
    }
    
    // 余因子行列を計算
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            double submatrix[3][3];
            int sub_i = 0;
            
            for (int row = 0; row < SIZE; row++) {
                if (row != i) {
                    int sub_j = 0;
                    for (int col = 0; col < SIZE; col++) {
                        if (col != j) {
                            submatrix[sub_i][sub_j] = matrix[row][col];
                            sub_j++;
                        }
                    }
                    sub_i++;
                }
            }
            
            double cofactor = determinant_3x3(submatrix);
            if ((i + j) % 2 == 1) {
                cofactor = -cofactor;
            }
            
            // 転置して余因子行列を随伴行列にする
            result[j][i] = cofactor / det;
        }
    }
    
    return 1;
}

// トレース（対角和）の計算
double trace_matrix(Matrix4x4 matrix) {
    double trace = 0;
    for (int i = 0; i < SIZE; i++) {
        trace += matrix[i][i];
    }
    return trace;
}

// 行列のコピー
void copy_matrix(Matrix4x4 src, Matrix4x4 dest) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            dest[i][j] = src[i][j];
        }
    }
}

// 単位行列の作成
void identity_matrix(Matrix4x4 matrix) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            matrix[i][j] = (i == j) ? 1.0 : 0.0;
        }
    }
}

int main() {
    printf("=== 4x4行列計算プログラム ===\n\n");
    
    // サンプル行列の初期化
    Matrix4x4 matrix_a = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };
    
    Matrix4x4 matrix_b = {
        {2, 0, 1, 3},
        {1, 1, 0, 2},
        {0, 1, 2, 1},
        {1, 0, 1, 1}
    };
    
    Matrix4x4 result;
    
    // 行列の表示
    print_matrix(matrix_a, "行列 A");
    print_matrix(matrix_b, "行列 B");
    
    // 加算
    add_matrices(matrix_a, matrix_b, result);
    print_matrix(result, "A + B");
    
    // 減算
    subtract_matrices(matrix_a, matrix_b, result);
    print_matrix(result, "A - B");
    
    // 乗算
    multiply_matrices(matrix_a, matrix_b, result);
    print_matrix(result, "A × B");
    
    // スカラー倍
    scalar_multiply(matrix_a, 2.0, result);
    print_matrix(result, "A × 2");
    
    // 転置
    transpose_matrix(matrix_a, result);
    print_matrix(result, "A の転置");
    
    // 行列式
    printf("A の行列式: %.2f\n", determinant_4x4(matrix_a));
    printf("B の行列式: %.2f\n\n", determinant_4x4(matrix_b));
    
    // トレース
    printf("A のトレース: %.2f\n", trace_matrix(matrix_a));
    printf("B のトレース: %.2f\n\n", trace_matrix(matrix_b));
    
    // 逆行列（Bで試す）
    if (inverse_matrix(matrix_b, result)) {
        print_matrix(result, "B の逆行列");
        
        // 検証: B × B^(-1) = I
        Matrix4x4 verification;
        multiply_matrices(matrix_b, result, verification);
        print_matrix(verification, "検証 B × B^(-1)（単位行列になるはず）");
    }
    
    // 単位行列の例
    Matrix4x4 identity;
    identity_matrix(identity);
    print_matrix(identity, "単位行列");
    
    return 0;
}
